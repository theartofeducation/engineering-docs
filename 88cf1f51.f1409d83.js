(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{73:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return l}));var a=n(2),r=n(6),o=(n(0),n(92)),i={slug:"/best-practices/dependency-updates",title:"Dependency Updates"},s={unversionedId:"best-practices/dependency-updates",id:"best-practices/dependency-updates",isDocsHomePage:!1,title:"Dependency Updates",description:"When Dependabot creates a PR to update a dependency, it is nearly always because there is a newer version that has security fixes over the version that is currently being used. The nice thing about this is that Dependabot creates pull requests in GitHub to get these changes reviewed, and the pull requests that it creates are like any other pull request, which means that all of our configured PR rules will apply, which means that all of our CI tasks will be run, to ensure that no tests are broken, and no linting issues have been introduced. Merging these PRs in will also require the same review approvals that all PRs require, so they will be required to have not only the full number of approved reviews, but also will be required to be signed off on by QA and the codeowner as well.",source:"@site/docs/best-practices/dependency-updates.md",slug:"/best-practices/dependency-updates",permalink:"/pages/best-practices/dependency-updates",editUrl:"https://github.com/theartofeducation/engineering-docs/docs/best-practices/dependency-updates.md",version:"current",sidebar:"docs",previous:{title:"Accessibility (a11y)",permalink:"/pages/best-practices/accessibility"},next:{title:"Documentation",permalink:"/pages/best-practices/documentation"}},c=[],p={rightToc:c};function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"When ",Object(o.b)("a",{parentName:"p",href:"https://dependabot.com/"},"Dependabot")," creates a PR to update a dependency, it is nearly always because there is a newer version that has security fixes over the version that is currently being used. The nice thing about this is that Dependabot creates pull requests in ",Object(o.b)("a",{parentName:"p",href:"https://github.com/"},"GitHub")," to get these changes reviewed, and the pull requests that it creates are like any other pull request, which means that all of our configured PR rules will apply, which means that all of our CI tasks will be run, to ensure that no tests are broken, and no linting issues have been introduced. Merging these PRs in will also require the same review approvals that all PRs require, so they will be required to have not only the full number of approved reviews, but also will be required to be signed off on by QA and the codeowner as well."),Object(o.b)("p",null,"Our standard process ensures that in the vast majority of cases, the proposed update should be fine. However, we want to be at very least cautious about reviewing and approving these changes to help identify the scope of impact of the library being updated. In many cases, Dependabot will be proposing an update to a small library that is a nested dependency whose focus and functionality will be very specific functionality, and will only have potential impact on a minimal amount of code. However, in some cases, the proposed update could be much more broadly scoped and could have significant, sweeping impact to the functionality of the app."),Object(o.b)("p",null,"For example, recently, Dependabot proposed an update to ",Object(o.b)("a",{parentName:"p",href:"https://nextjs.org/"},"Next.js")," in a frontend application. Next.js is the foundational framework that the project is based on. The update was significant and would have had a huge potential impact on the application. In these cases, we will want to have some conversation around how we want to vet the proposed updates before considering it. In some cases we may choose to simply close the PR and create a story to vet and test the update when we can prioritize the time to go through the project fully."))}l.isMDXComponent=!0},92:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),l=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),h=a,b=u["".concat(i,".").concat(h)]||u[h]||d[h]||o;return n?r.a.createElement(b,s(s({ref:t},p),{},{components:n})):r.a.createElement(b,s({ref:t},p))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);